package com.centurylink.dsp.valueobjects.abs;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.centurylink.dsp.valueobjects.impl.Field;
import com.centurylink.dsp.valueobjects.model.Table;


public abstract class AbstractReadWriteTable extends AbstractReadOnlyTable {
	
	private static final long serialVersionUID = 1L;

	private static final Log LOG = LogFactory.getLog(AbstractReadWriteTable.class);

	public AbstractReadWriteTable()
	{
		super();
	}
	
	public void save() throws Exception
	{
		preSave();
		if (isInstanciated())
		{
			doUpdate();
		} else {
			doInsert();
		}
		getRecordByPrimaryKey(true);
		this.instanciated = true;
		
		//As these are all shorted lived caches at the moment, anytime an update is done I'm going to clear all Cache elements
		valueObjectDataAccessUtil.clearCache();
		
		postSave();
	}
	
	protected void preSave()
	{
		//Allowed for SubClass to overwrite method with specific implementations
	}
	
	protected void postSave()
	{
		//Allowed for SubClass to overwrite method with specific implementations
	}

	public void delete()
	{
		preDelete();
		String statement = "DELETE FROM " + this.tableName + " WHERE " + primaryKey.getQueryValue();
		valueObjectDataAccessUtil.executeStatement(statement);
		this.instanciated = false;

		//As these are all shorted lived caches at the moment, anytime an update is done I'm going to clear all Cache elements
		valueObjectDataAccessUtil.clearCache();
		
		postDelete();
	}
	
	
	protected void preDelete()
	{
		//Allowed for SubClass to overwrite method with specific implementations
	}
	
	protected void postDelete()
	{
		//Allowed for SubClass to overwrite method with specific implementations
	}
	
	protected void doInsert()
	{
		String statement = buildInsertStatement();
		LOG.debug(statement);
		valueObjectDataAccessUtil.executeStatement(statement);
	}
	
	protected String buildInsertStatement()
	{
		boolean firstTime = true;
		
		String statement = "INSERT INTO " + this.tableName + " (";

		for (Field field:fields.values())
		{
			//need to handle auto set fields also
			if (field.getValue() != null || field.isAutoGenerated())
			{
				if (firstTime)
					firstTime = false;
				else
					statement += ", ";
				
				statement += field.getName();
			}
		}

		statement += ") VALUES (";

		firstTime = true;
		for (Field field:fields.values())
		{
			//need to handle auto set fields also
			if (field.getValue() != null || field.isAutoGenerated())
			{
				if (firstTime)
					firstTime = false;
				else
					statement += ", ";
		
				//need to add getInsertValue
				statement += field.getInsertValue();
			}
		}
		
		statement += ")";
		
		return statement;
	}
	
	protected void doUpdate()
	{
		String statement = buildUpdateStatement();
		LOG.debug(statement);
		valueObjectDataAccessUtil.executeStatement(statement);
	}
	
	protected String buildUpdateStatement()
	{
		boolean firstTime = true;
		
		String statement = "UPDATE " + this.tableName + " SET ";

		for (Field field:fields.values())
		{
			if (field.isChangeable() && (field.hasChanged() || field.isAutoGenerated()))
			{
				if (firstTime)
					firstTime = false;
				else
					statement += ", ";
				
				statement += field.getName() + " = " + field.getInsertValue();
			}
		}
		
		statement += " WHERE " + primaryKey.getQueryValue();
		
		return statement;
	}
	
}
